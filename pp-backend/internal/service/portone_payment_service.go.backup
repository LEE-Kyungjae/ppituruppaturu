// backend/internal/service/portone_payment_service.go
package service

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/pitturu-ppaturu/backend/internal/portone"
	"github.com/pitturu-ppaturu/backend/internal/repository"
	serviceErrors "github.com/pitturu-ppaturu/backend/internal/service/errors"

	"github.com/google/uuid"
)

// PortOnePaymentService handles PortOne PG integration
type PortOnePaymentService interface {
	// Payment Session Management
	CreatePaymentSession(req CreatePaymentSessionRequest) (*PaymentSessionResponse, error)
	GetPaymentSession(sessionID string) (*PaymentSessionResponse, error)
	
	// Payment Processing
	PreparePayment(sessionID string) (*PreparePaymentResponse, error)
	VerifyPayment(impUID string) (*VerifyPaymentResult, error)
	HandleWebhook(payload portone.WebhookPayload) error
	
	// Payment Management
	CancelPayment(paymentID string, reason string) (*CancelPaymentResult, error)
	GetPaymentHistory(userID string, limit, offset int) ([]*PaymentHistoryItem, error)
}

// Request/Response types
type CreatePaymentSessionRequest struct {
	UserID      string                    `json:"user_id"`
	ItemID      uuid.UUID                 `json:"item_id"`
	Quantity    int                       `json:"quantity"`
	BuyerInfo   portone.BuyerInfo        `json:"buyer_info"`
	RedirectURL string                    `json:"redirect_url"`
}

type PaymentSessionResponse struct {
	SessionID   string                `json:"session_id"`
	MerchantUID string                `json:"merchant_uid"`
	Item        repository.Item       `json:"item"`
	Amount      int64                 `json:"amount"`
	Currency    string                `json:"currency"`
	BuyerInfo   portone.BuyerInfo    `json:"buyer_info"`
	Status      string                `json:"status"`
	CreatedAt   time.Time             `json:"created_at"`
}

type PreparePaymentResponse struct {
	MerchantUID string `json:"merchant_uid"`
	Amount      int64  `json:"amount"`
	Success     bool   `json:"success"`
	Message     string `json:"message,omitempty"`
}

type VerifyPaymentResult struct {
	PaymentID   string                        `json:"payment_id"`
	ImpUID      string                        `json:"imp_uid"`
	MerchantUID string                        `json:"merchant_uid"`
	Status      portone.PaymentStatus        `json:"status"`
	Amount      int64                         `json:"amount"`
	PaidAt      *time.Time                    `json:"paid_at,omitempty"`
	Transaction *repository.Transaction       `json:"transaction,omitempty"`
	Success     bool                          `json:"success"`
	Message     string                        `json:"message,omitempty"`
}

type CancelPaymentResult struct {
	PaymentID      string    `json:"payment_id"`
	CancelAmount   int64     `json:"cancel_amount"`
	CancelledAt    time.Time `json:"cancelled_at"`
	Success        bool      `json:"success"`
	Message        string    `json:"message,omitempty"`
}

type PaymentHistoryItem struct {
	PaymentID   string                `json:"payment_id"`
	ImpUID      string                `json:"imp_uid"`
	MerchantUID string                `json:"merchant_uid"`
	ItemName    string                `json:"item_name"`
	Amount      int64                 `json:"amount"`
	Status      portone.PaymentStatus `json:"status"`
	CreatedAt   time.Time             `json:"created_at"`
	PaidAt      *time.Time            `json:"paid_at,omitempty"`
}

// portOnePaymentService implementation
type portOnePaymentService struct {
	portoneClient   *portone.Client
	paymentRepo     repository.PaymentRepository
	itemRepo        repository.ItemRepository
	userRepo        repository.UserRepository
	transactionRepo repository.TransactionRepository
	baseURL         string
}

// NewPortOnePaymentService creates a new PortOne payment service
func NewPortOnePaymentService(
	portoneClient *portone.Client,
	paymentRepo repository.PaymentRepository,
	itemRepo repository.ItemRepository,
	userRepo repository.UserRepository,
	transactionRepo repository.TransactionRepository,
	baseURL string,
) PortOnePaymentService {
	return &portOnePaymentService{
		portoneClient:   portoneClient,
		paymentRepo:     paymentRepo,
		itemRepo:        itemRepo,
		userRepo:        userRepo,
		transactionRepo: transactionRepo,
		baseURL:         baseURL,
	}
}

// CreatePaymentSession creates a new payment session
func (s *portOnePaymentService) CreatePaymentSession(req CreatePaymentSessionRequest) (*PaymentSessionResponse, error) {
	// Validate user exists
	_, err := s.userRepo.GetUserByUsername(req.UserID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, serviceErrors.ErrUserNotFound
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Get item details
	item, err := s.itemRepo.GetItemByID(req.ItemID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, serviceErrors.ErrItemNotFound
		}
		return nil, fmt.Errorf("failed to get item: %w", err)
	}

	// Validate item has cash price
	if !item.PriceCash.Valid || item.PriceCash.Int32 <= 0 {
		return nil, serviceErrors.ErrInvalidPurchase
	}

	// Generate unique merchant UID
	merchantUID := fmt.Sprintf("PITTURU_%s_%d", uuid.New().String()[:8], time.Now().Unix())

	// Calculate total amount
	totalAmount := int64(item.PriceCash.Int32 * int32(req.Quantity))

	// Create payment session in database
	paymentSession := &repository.PaymentSession{
		ID:          uuid.New(),
		MerchantUID: merchantUID,
		UserID:      req.UserID,
		ItemID:      req.ItemID,
		Quantity:    req.Quantity,
		Amount:      totalAmount,
		Currency:    "KRW", // Default to Korean Won
		BuyerName:   req.BuyerInfo.Name,
		BuyerEmail:  req.BuyerInfo.Email,
		BuyerTel:    req.BuyerInfo.Tel,
		BuyerAddr:   sql.NullString{String: req.BuyerInfo.Addr, Valid: req.BuyerInfo.Addr != ""},
		BuyerPostcode: sql.NullString{String: req.BuyerInfo.Postcode, Valid: req.BuyerInfo.Postcode != ""},
		Status:      string(portone.PaymentStatusReady),
		RedirectURL: req.RedirectURL,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	createdSession, err := s.paymentRepo.CreatePaymentSession(paymentSession)
	if err != nil {
		return nil, fmt.Errorf("failed to create payment session: %w", err)
	}

	return &PaymentSessionResponse{
		SessionID:   createdSession.ID.String(),
		MerchantUID: createdSession.MerchantUID,
		Item:        *item,
		Amount:      createdSession.Amount,
		Currency:    createdSession.Currency,
		BuyerInfo:   req.BuyerInfo,
		Status:      createdSession.Status,
		CreatedAt:   createdSession.CreatedAt,
	}, nil
}

// GetPaymentSession retrieves a payment session
func (s *portOnePaymentService) GetPaymentSession(sessionID string) (*PaymentSessionResponse, error) {
	sessionUUID, err := uuid.Parse(sessionID)
	if err != nil {
		return nil, fmt.Errorf("invalid session ID: %w", err)
	}

	session, err := s.paymentRepo.GetPaymentSession(sessionUUID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("payment session not found")
		}
		return nil, fmt.Errorf("failed to get payment session: %w", err)
	}

	item, err := s.itemRepo.GetItemByID(session.ItemID)
	if err != nil {
		return nil, fmt.Errorf("failed to get item: %w", err)
	}

	buyerInfo := portone.BuyerInfo{
		Name:     session.BuyerName,
		Email:    session.BuyerEmail,
		Tel:      session.BuyerTel,
		Addr:     session.BuyerAddr.String,
		Postcode: session.BuyerPostcode.String,
	}

	return &PaymentSessionResponse{
		SessionID:   session.ID.String(),
		MerchantUID: session.MerchantUID,
		Item:        *item,
		Amount:      session.Amount,
		Currency:    session.Currency,
		BuyerInfo:   buyerInfo,
		Status:      session.Status,
		CreatedAt:   session.CreatedAt,
	}, nil
}

// PreparePayment prepares payment with PortOne
func (s *portOnePaymentService) PreparePayment(sessionID string) (*PreparePaymentResponse, error) {
	session, err := s.GetPaymentSession(sessionID)
	if err != nil {
		return nil, err
	}

	// Prepare payment with PortOne
	req := portone.PreparePaymentRequest{
		MerchantUID:   session.MerchantUID,
		Amount:        session.Amount,
		Currency:      session.Currency,
		Name:          session.Item.Name,
		BuyerName:     session.BuyerInfo.Name,
		BuyerEmail:    session.BuyerInfo.Email,
		BuyerTel:      session.BuyerInfo.Tel,
		BuyerAddr:     session.BuyerInfo.Addr,
		BuyerPostcode: session.BuyerInfo.Postcode,
		NoticeURL:     fmt.Sprintf("%s/api/v1/payments/webhook", s.baseURL),
		ReturnURL:     fmt.Sprintf("%s/payment/success", s.baseURL),
	}

	resp, err := s.portoneClient.PreparePayment(req)
	if err != nil {
		return &PreparePaymentResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to prepare payment: %v", err),
		}, nil
	}

	return &PreparePaymentResponse{
		MerchantUID: resp.Response.MerchantUID,
		Amount:      resp.Response.Amount,
		Success:     resp.Code == 0,
		Message:     resp.Message,
	}, nil
}

// VerifyPayment verifies payment completion with PortOne
func (s *portOnePaymentService) VerifyPayment(impUID string) (*VerifyPaymentResult, error) {
	// Verify payment with PortOne
	resp, err := s.portoneClient.VerifyPayment(impUID)
	if err != nil {
		return &VerifyPaymentResult{
			Success: false,
			Message: fmt.Sprintf("Failed to verify payment: %v", err),
		}, nil
	}

	if resp.Code != 0 {
		return &VerifyPaymentResult{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	payment := resp.Response

	// Get payment session
	session, err := s.paymentRepo.GetPaymentSessionByMerchantUID(payment.MerchantUID)
	if err != nil {
		return &VerifyPaymentResult{
			Success: false,
			Message: "Payment session not found",
		}, nil
	}

	result := &VerifyPaymentResult{
		ImpUID:      payment.ImpUID,
		MerchantUID: payment.MerchantUID,
		Status:      payment.Status,
		Amount:      payment.PaidAmount,
		Success:     payment.Status == portone.PaymentStatusPaid,
	}

	if payment.PaidAt > 0 {
		paidAt := time.Unix(payment.PaidAt, 0)
		result.PaidAt = &paidAt
	}

	// If payment is successful, create transaction and update inventory
	if payment.Status == portone.PaymentStatusPaid {
		// Create transaction record
		transaction := &repository.Transaction{
			ID:              uuid.New(),
			UserUsername:    session.UserID,
			ItemID:          session.ItemID,
			TransactionType: "cash_purchase",
			Amount:          float64(payment.PaidAmount),
			Currency:        "KRW",
			PaymentGatewayID: sql.NullString{String: payment.ImpUID, Valid: true},
			Status:          "completed",
			CreatedAt:       time.Now(),
		}

		createdTransaction, err := s.transactionRepo.CreateTransaction(transaction)
		if err != nil {
			return &VerifyPaymentResult{
				Success: false,
				Message: "Failed to create transaction record",
			}, nil
		}

		result.Transaction = createdTransaction
		result.PaymentID = createdTransaction.ID.String()

		// Add item to user's inventory
		// This would typically be handled by the existing PaymentService
		// For now, we'll just update the payment session status
		session.Status = string(portone.PaymentStatusPaid)
		session.UpdatedAt = time.Now()
		
		err = s.paymentRepo.UpdatePaymentSession(session)
		if err != nil {
			// Log error but don't fail the payment verification
			fmt.Printf("Failed to update payment session status: %v\n", err)
		}
	}

	return result, nil
}

// HandleWebhook processes PortOne webhook notifications
func (s *portOnePaymentService) HandleWebhook(payload portone.WebhookPayload) error {
	// Verify payment status with PortOne API to ensure webhook authenticity
	_, err := s.VerifyPayment(payload.ImpUID)
	if err != nil {
		return fmt.Errorf("failed to verify webhook payment: %w", err)
	}

	// Additional webhook processing can be added here
	// such as sending notifications, updating analytics, etc.

	return nil
}

// CancelPayment cancels a payment
func (s *portOnePaymentService) CancelPayment(paymentID string, reason string) (*CancelPaymentResult, error) {
	// Get payment record
	paymentUUID, err := uuid.Parse(paymentID)
	if err != nil {
		return nil, fmt.Errorf("invalid payment ID: %w", err)
	}

	transaction, err := s.transactionRepo.GetTransactionByID(paymentUUID)
	if err != nil {
		return nil, fmt.Errorf("payment not found: %w", err)
	}

	if !transaction.PaymentGatewayID.Valid {
		return nil, fmt.Errorf("payment gateway ID not found")
	}

	// Cancel payment with PortOne
	cancelReq := portone.CancelPaymentRequest{
		ImpUID: transaction.PaymentGatewayID.String,
		Reason: reason,
	}

	resp, err := s.portoneClient.CancelPayment(cancelReq)
	if err != nil {
		return &CancelPaymentResult{
			Success: false,
			Message: fmt.Sprintf("Failed to cancel payment: %v", err),
		}, nil
	}

	if resp.Code != 0 {
		return &CancelPaymentResult{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Update transaction status
	transaction.Status = "cancelled"
	err = s.transactionRepo.UpdateTransaction(transaction)
	if err != nil {
		return &CancelPaymentResult{
			Success: false,
			Message: "Failed to update transaction status",
		}, nil
	}

	return &CancelPaymentResult{
		PaymentID:    paymentID,
		CancelAmount: resp.Response.CancelAmount,
		CancelledAt:  time.Unix(resp.Response.CancelledAt, 0),
		Success:      true,
	}, nil
}

// GetPaymentHistory retrieves payment history for a user
func (s *portOnePaymentService) GetPaymentHistory(userID string, limit, offset int) ([]*PaymentHistoryItem, error) {
	transactions, err := s.transactionRepo.GetTransactionsByUser(userID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get payment history: %w", err)
	}

	var history []*PaymentHistoryItem
	for _, tx := range transactions {
		item := &PaymentHistoryItem{
			PaymentID:   tx.ID.String(),
			MerchantUID: tx.PaymentGatewayID.String,
			Amount:      int64(tx.Amount),
			CreatedAt:   tx.CreatedAt,
		}

		// Get item details if available
		if tx.ItemID != uuid.Nil {
			itemDetails, err := s.itemRepo.GetItemByID(tx.ItemID)
			if err == nil {
				item.ItemName = itemDetails.Name
			}
		}

		// Set payment status based on transaction status
		switch tx.Status {
		case "completed":
			item.Status = portone.PaymentStatusPaid
		case "cancelled":
			item.Status = portone.PaymentStatusCancelled
		case "failed":
			item.Status = portone.PaymentStatusFailed
		default:
			item.Status = portone.PaymentStatusReady
		}

		history = append(history, item)
	}

	return history, nil
}