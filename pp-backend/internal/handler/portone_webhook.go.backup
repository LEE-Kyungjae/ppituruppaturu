package handler

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/pitturu-ppaturu/backend/internal/config"
	"github.com/pitturu-ppaturu/backend/internal/errors"
	"github.com/pitturu-ppaturu/backend/internal/logger"
	"github.com/pitturu-ppaturu/backend/internal/service"
)

// PortOneWebhookHandler handles PortOne webhook notifications
type PortOneWebhookHandler struct {
	paymentService *service.PaymentService
	portOneConfig  config.PortOneConfig
	logger         *logger.Logger
}

// PortOneWebhookPayload represents the webhook payload from PortOne
type PortOneWebhookPayload struct {
	ImpUID         string  `json:"imp_uid"`
	MerchantUID    string  `json:"merchant_uid"`
	Status         string  `json:"status"`
	Amount         int64   `json:"amount"`
	CancelAmount   int64   `json:"cancel_amount,omitempty"`
	Currency       string  `json:"currency"`
	Name           string  `json:"name"`
	PgProvider     string  `json:"pg_provider"`
	PgTid          string  `json:"pg_tid"`
	BuyerName      string  `json:"buyer_name"`
	BuyerEmail     string  `json:"buyer_email"`
	BuyerTel       string  `json:"buyer_tel"`
	BuyerAddr      string  `json:"buyer_addr"`
	BuyerPostcode  string  `json:"buyer_postcode"`
	CustomData     string  `json:"custom_data,omitempty"`
	PaidAt         int64   `json:"paid_at"`
	ReceiptURL     string  `json:"receipt_url"`
	CancelledAt    int64   `json:"cancelled_at,omitempty"`
	CancelReason   string  `json:"cancel_reason,omitempty"`
	FailReason     string  `json:"fail_reason,omitempty"`
	CardName       string  `json:"card_name,omitempty"`
	CardNumber     string  `json:"card_number,omitempty"`
	CardQuota      int     `json:"card_quota,omitempty"`
	VbankName      string  `json:"vbank_name,omitempty"`
	VbankNum       string  `json:"vbank_num,omitempty"`
	VbankHolder    string  `json:"vbank_holder,omitempty"`
	VbankDate      int64   `json:"vbank_date,omitempty"`
}

// WebhookResponse represents the response to PortOne webhook
type WebhookResponse struct {
	Status  string `json:"status"`
	Message string `json:"message,omitempty"`
}

// NewPortOneWebhookHandler creates a new webhook handler
func NewPortOneWebhookHandler(paymentService *service.PaymentService) *PortOneWebhookHandler {
	return &PortOneWebhookHandler{
		paymentService: paymentService,
		portOneConfig:  config.GetPortOneConfig(),
		logger:         logger.GetLogger(),
	}
}

// HandleWebhook handles PortOne webhook notifications
func (h *PortOneWebhookHandler) HandleWebhook(c *gin.Context) {
	requestID := c.GetString("request_id")
	startTime := time.Now()
	
	// Log the webhook request
	h.logger.WithFields(logger.Fields{
		"request_id": requestID,
		"source":     "portone_webhook",
	}).Info("Received PortOne webhook")
	
	// Read the request body
	bodyBytes, err := io.ReadAll(c.Request.Body)
	if err != nil {
		appErr := errors.NewValidationError("INVALID_WEBHOOK_BODY", "Failed to read webhook body", err.Error())
		h.respondWithError(c, appErr)
		return
	}
	
	// Verify webhook signature if configured
	if err := h.verifyWebhookSignature(c.Request, bodyBytes); err != nil {
		appErr := errors.NewAuthenticationError("Invalid webhook signature")
		h.logger.LogSecurityEvent("invalid_webhook_signature", "", c.ClientIP(), logger.Fields{
			"request_id": requestID,
			"error":      err.Error(),
		})
		h.respondWithError(c, appErr)
		return
	}
	
	// Parse the webhook payload
	var payload PortOneWebhookPayload
	if err := json.Unmarshal(bodyBytes, &payload); err != nil {
		appErr := errors.NewValidationError("INVALID_WEBHOOK_PAYLOAD", "Failed to parse webhook payload", err.Error())
		h.respondWithError(c, appErr)
		return
	}
	
	// Log the webhook payload (excluding sensitive data)
	h.logger.WithFields(logger.Fields{
		"request_id":   requestID,
		"imp_uid":      payload.ImpUID,
		"merchant_uid": payload.MerchantUID,
		"status":       payload.Status,
		"amount":       payload.Amount,
		"pg_provider":  payload.PgProvider,
	}).Info("Processing PortOne webhook")
	
	// Process the webhook based on status
	if err := h.processWebhook(c.Request.Context(), &payload, requestID); err != nil {
		h.logger.WithFields(logger.Fields{
			"request_id": requestID,
			"imp_uid":    payload.ImpUID,
			"error":      err.Error(),
		}).Error("Failed to process webhook")
		
		h.respondWithError(c, err)
		return
	}
	
	// Log successful processing
	duration := time.Since(startTime)
	h.logger.LogPerformance("portone_webhook_processing", duration, logger.Fields{
		"request_id": requestID,
		"imp_uid":    payload.ImpUID,
		"status":     payload.Status,
	})
	
	// Respond with success
	c.JSON(http.StatusOK, WebhookResponse{
		Status: "success",
	})
}

// processWebhook processes the webhook based on payment status
func (h *PortOneWebhookHandler) processWebhook(ctx gin.Context, payload *PortOneWebhookPayload, requestID string) *errors.AppError {
	switch payload.Status {
	case "paid":
		return h.handlePaymentSuccess(ctx, payload, requestID)
	case "failed":
		return h.handlePaymentFailure(ctx, payload, requestID)
	case "cancelled":
		return h.handlePaymentCancellation(ctx, payload, requestID)
	case "partial_cancelled":
		return h.handlePartialCancellation(ctx, payload, requestID)
	default:
		h.logger.WithFields(logger.Fields{
			"request_id": requestID,
			"status":     payload.Status,
			"imp_uid":    payload.ImpUID,
		}).Warn("Unknown payment status received")
		return nil
	}
}

// handlePaymentSuccess handles successful payment webhook
func (h *PortOneWebhookHandler) handlePaymentSuccess(ctx gin.Context, payload *PortOneWebhookPayload, requestID string) *errors.AppError {
	// Verify payment with PortOne API
	verificationResult, err := h.paymentService.VerifyPaymentWithPortOne(ctx, payload.ImpUID)
	if err != nil {
		return errors.Wrap(err, "Failed to verify payment with PortOne")
	}
	
	// Check if amounts match
	if verificationResult.Amount != payload.Amount {
		h.logger.LogSecurityEvent("payment_amount_mismatch", "", ctx.ClientIP(), logger.Fields{
			"request_id":       requestID,
			"imp_uid":          payload.ImpUID,
			"webhook_amount":   payload.Amount,
			"verified_amount":  verificationResult.Amount,
		})
		return errors.NewPaymentError("AMOUNT_MISMATCH", "Payment amount mismatch detected", nil)
	}
	
	// Update payment status in database
	if err := h.paymentService.CompletePayment(ctx, payload.ImpUID, &service.PaymentCompletionData{
		PgTid:        payload.PgTid,
		PgProvider:   payload.PgProvider,
		CardName:     payload.CardName,
		CardNumber:   maskCardNumber(payload.CardNumber),
		CardQuota:    payload.CardQuota,
		PaidAt:       time.Unix(payload.PaidAt, 0),
		ReceiptURL:   payload.ReceiptURL,
		CustomData:   payload.CustomData,
	}); err != nil {
		return errors.Wrap(err, "Failed to complete payment in database")
	}
	
	// Log successful payment
	h.logger.LogPaymentOperation("webhook_success", payload.ImpUID, "", payload.Amount, nil)
	
	// Trigger post-payment processes (notifications, rewards, etc.)
	h.triggerPostPaymentProcesses(ctx, payload)
	
	return nil
}

// handlePaymentFailure handles failed payment webhook
func (h *PortOneWebhookHandler) handlePaymentFailure(ctx gin.Context, payload *PortOneWebhookPayload, requestID string) *errors.AppError {
	// Update payment status to failed
	if err := h.paymentService.FailPayment(ctx, payload.ImpUID, payload.FailReason); err != nil {
		return errors.Wrap(err, "Failed to update payment failure in database")
	}
	
	// Log payment failure
	h.logger.LogPaymentOperation("webhook_failure", payload.ImpUID, "", payload.Amount, 
		fmt.Errorf("payment failed: %s", payload.FailReason))
	
	// Trigger failure notifications
	h.triggerPaymentFailureProcesses(ctx, payload)
	
	return nil
}

// handlePaymentCancellation handles payment cancellation webhook
func (h *PortOneWebhookHandler) handlePaymentCancellation(ctx gin.Context, payload *PortOneWebhookPayload, requestID string) *errors.AppError {
	// Update payment status to cancelled
	if err := h.paymentService.CancelPayment(ctx, payload.ImpUID, &service.PaymentCancellationData{
		CancelAmount: payload.CancelAmount,
		CancelReason: payload.CancelReason,
		CancelledAt:  time.Unix(payload.CancelledAt, 0),
	}); err != nil {
		return errors.Wrap(err, "Failed to cancel payment in database")
	}
	
	// Log payment cancellation
	h.logger.LogPaymentOperation("webhook_cancellation", payload.ImpUID, "", payload.CancelAmount, nil)
	
	// Trigger refund processes
	h.triggerPaymentCancellationProcesses(ctx, payload)
	
	return nil
}

// handlePartialCancellation handles partial payment cancellation
func (h *PortOneWebhookHandler) handlePartialCancellation(ctx gin.Context, payload *PortOneWebhookPayload, requestID string) *errors.AppError {
	// Update payment with partial cancellation
	if err := h.paymentService.PartialCancelPayment(ctx, payload.ImpUID, &service.PaymentCancellationData{
		CancelAmount: payload.CancelAmount,
		CancelReason: payload.CancelReason,
		CancelledAt:  time.Unix(payload.CancelledAt, 0),
	}); err != nil {
		return errors.Wrap(err, "Failed to process partial cancellation in database")
	}
	
	// Log partial cancellation
	h.logger.LogPaymentOperation("webhook_partial_cancellation", payload.ImpUID, "", payload.CancelAmount, nil)
	
	return nil
}

// verifyWebhookSignature verifies the webhook signature
func (h *PortOneWebhookHandler) verifyWebhookSignature(req *http.Request, body []byte) error {
	// Skip verification in development mode or if webhook secret is not configured
	if !h.portOneConfig.IsProductionReady() {
		return nil
	}
	
	webhookSecret := h.portOneConfig.WebhookSecret
	if webhookSecret == "" {
		h.logger.Warn("Webhook secret not configured, skipping signature verification")
		return nil
	}
	
	// Get signature from headers
	signature := req.Header.Get("X-IamportSignature")
	if signature == "" {
		return fmt.Errorf("missing webhook signature")
	}
	
	// Calculate expected signature
	mac := hmac.New(sha256.New, []byte(webhookSecret))
	mac.Write(body)
	expectedSignature := hex.EncodeToString(mac.Sum(nil))
	
	// Compare signatures
	if !hmac.Equal([]byte(signature), []byte(expectedSignature)) {
		return fmt.Errorf("invalid webhook signature")
	}
	
	return nil
}

// triggerPostPaymentProcesses triggers post-payment business processes
func (h *PortOneWebhookHandler) triggerPostPaymentProcesses(ctx gin.Context, payload *PortOneWebhookPayload) {
	// This would typically include:
	// - Sending confirmation emails
	// - Updating user points/credits
	// - Triggering reward systems
	// - Updating analytics
	// - Sending push notifications
	
	go func() {
		// Run in background to avoid blocking webhook response
		// In production, this should use a proper job queue
		h.logger.WithFields(logger.Fields{
			"imp_uid": payload.ImpUID,
			"amount":  payload.Amount,
		}).Info("Triggering post-payment processes")
		
		// Example: Award points to user
		// h.userService.AwardPoints(ctx, userID, pointsToAward)
		
		// Example: Send confirmation email
		// h.emailService.SendPaymentConfirmation(ctx, payload.BuyerEmail, payload)
	}()
}

// triggerPaymentFailureProcesses handles payment failure processes
func (h *PortOneWebhookHandler) triggerPaymentFailureProcesses(ctx gin.Context, payload *PortOneWebhookPayload) {
	go func() {
		h.logger.WithFields(logger.Fields{
			"imp_uid":     payload.ImpUID,
			"fail_reason": payload.FailReason,
		}).Info("Triggering payment failure processes")
		
		// Example: Send failure notification
		// h.emailService.SendPaymentFailureNotification(ctx, payload.BuyerEmail, payload)
	}()
}

// triggerPaymentCancellationProcesses handles payment cancellation processes
func (h *PortOneWebhookHandler) triggerPaymentCancellationProcesses(ctx gin.Context, payload *PortOneWebhookPayload) {
	go func() {
		h.logger.WithFields(logger.Fields{
			"imp_uid":       payload.ImpUID,
			"cancel_amount": payload.CancelAmount,
			"cancel_reason": payload.CancelReason,
		}).Info("Triggering payment cancellation processes")
		
		// Example: Process refund to user account
		// h.userService.ProcessRefund(ctx, userID, payload.CancelAmount)
	}()
}

// Helper functions
func maskCardNumber(cardNumber string) string {
	if len(cardNumber) <= 4 {
		return cardNumber
	}
	return "****-****-****-" + cardNumber[len(cardNumber)-4:]
}

func (h *PortOneWebhookHandler) respondWithError(c *gin.Context, appErr *errors.AppError) {
	c.JSON(appErr.HTTPStatusCode, WebhookResponse{
		Status:  "error",
		Message: appErr.Message,
	})
}